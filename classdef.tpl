@perl use lib ".";
@perl use Utility;
@//
@// Generate the class structures
@//
@foreach class_list          

@perl $myfilename=${class_name};
@perl $myexclusion=uc($myfilename."_h");
@perl print "Generating $myfilename.h\n";
@openfile $myfilename.h
//-*-mode:c++;-*-
/******************************************************************************

	File : $myfilename.h

	Do not edit this file it has been automatically generated 

******************************************************************************/

#ifndef $myexclusion
#define $myexclusion

#define __STL_USE_NAMESPACES

#include<iostream>
#include<string>
#include<vector>

#ifndef NO_COMPOUND_CH5
#include<hdf5/hdf5.h>
#endif

#include"Exceptions.h"

namespace NS_Analysis {

using std::iostream;
using std::string;
using std::vector;
using std::endl;

  @foreach attr_list 
    @if(defined $include)
// Included for $attr_list
#include${include}
    @endif
  @end

class ${class_name}
{
private:

  // DATA MEMBERS

  @foreach attr_list 
    @perl $l=Utility::PrintElement($attr_type,$attr_name,$dim,$comment,$unit,22);
  $l
  @end

  unsigned int m_version;

public:
  typedef unsigned int size_type;   

  unsigned int version() const { return m_version; }
  unsigned int getVersion() const { return m_version; }
  void setVersion(unsigned int v) { m_version=v; }

  inline void zero(void);
  
  ${class_name}(): m_version(0) { /* zero(); */ }
	
  ////////////////////////////////////////////////////////////////////////////
  ////////////////////////////// ACCESSORS ///////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////

  @foreach attr_list 
  // Member: $attr_name
    @perl $lcname=Utility::LCName($attr_name);
    @perl $ctype=Utility::MType($attr_type);
    @if((defined $dim)&&($attr_type ne "string"))
  inline const ${ctype}* get${attr_name}() const { return m_${attr_name}; }
  inline vector<${ctype}>& get${attr_name}(vector<$ctype>& v) const;
  inline $ctype get${attr_name}(size_type n) const;
  inline const ${ctype}* ${lcname}() const { return get${attr_name}(); }
    @elsif((defined $dim)&&($attr_type eq "string"))
  inline string& get${attr_name}(string& s) const;
  inline string get${attr_name}() const;
  inline string ${lcname}() const { return get${attr_name}(); }
    @else
  inline $ctype get${attr_name}() const;
  inline $ctype ${lcname}() const { return get${attr_name}(); }
    @endif
  @end

  ////////////////////////////////////////////////////////////////////////////
  //////////////////////////// SET ACCESSORS /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////

  @foreach attr_list 
    @if ( not defined $readonly )
  // Member: $attr_name
      @perl $lcname=Utility::LCName($attr_name);
      @perl $ctype=Utility::MType($attr_type);
      @if((defined $dim)&&($attr_type ne "string"))
  inline void set${attr_name}(const ${ctype}* x);
  inline void set${attr_name}(const vector<$ctype>& v);
  inline void set${attr_name}(const ${ctype}& x, size_type n);
      @elsif((defined $dim)&&($attr_type eq "string"))
  inline void set${attr_name}(const string& s);
      @else
  inline void set${attr_name}(const ${ctype}& x){ m_${attr_name}=x; }
        @endif
    @endif
  @end

  ////////////////////////////////////////////////////////////////////////////
  ////////////////////////// MEMBER DIMENSIONS ///////////////////////////////
  ////////////////////////////////////////////////////////////////////////////

  // There may not be any functions here if there are no members that are
  // arrays. Don't be scared if there aren't
  @foreach attr_list 
    @if(defined $dim)
  inline static size_type size${attr_name}(unsigned int v);
    @endif
  @end

  @foreach attr_list 
    @if(defined $dim)
  size_type size${attr_name}() const { return size${attr_name}(version()); }
    @endif
  @end

  ////////////////////////////////////////////////////////////////////////////
  /////////////////////////// VERSION CHECKS /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////

  @foreach attr_list 
    @if(defined $version)
  inline static bool has${attr_name}(unsigned int v);
    @else
  inline static bool has${attr_name}(unsigned int v) { return true; }
    @endif
  @end

  @foreach attr_list 
  bool has${attr_name}() const { return has${attr_name}(version()); }
  @end

  ostream& streamDumpLong(ostream& stream) const;
  ostream& streamDumpShort(ostream& stream) const;

#ifndef NO_COMPOUND_CH5
  //---------------------------------------------------------------------------
  // Create HDF5 compound datatypes for this structure. The two static members
  // create H5 compound types for the internal representaion of this class and
  // for the Little-Endian (INTEL ARCHICTECTURE) that is stored on disk.
  //---------------------------------------------------------------------------

public:
  static hid_t compoundCH5Core(unsigned int version);  // HDF5 NATIVE UNPACKED
  static hid_t compoundCH5Disk(unsigned int version, 
                               bool pack=true);        // HDF5 INTEL PACKED 
#endif /* NO_COMPOUND_H5 */
};

// Dump the attributes to an output stream
ostream& operator<<(ostream& stream, const ${class_name}& me);

} /* namespace NS_Analysis */

inline void NS_Analysis::${class_name}::zero()
{
  @foreach attr_list 
    @if((defined $dim) && ($attr_type ne "string"))
  for(int i=0;i<$dim;i++)m_${attr_name}[i]=0;
    @elsif($attr_type eq "string")
  *m_$attr_name=0;
    @else
  m_$attr_name=0;
    @endif
  @end  
}

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// ACCESSORS ////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

  @foreach attr_list 
    @perl $lcname=Utility::LCName($attr_name);
    @perl $ctype=Utility::MType($attr_type);
    @if((defined $dim)&&($attr_type ne "string"))
// Member: $attr_name
inline std::vector<${ctype}>& 
NS_Analysis::${class_name}::
get${attr_name}(std::vector<$ctype>& v) const
{
  // Version check is in size${attr_name}()
  size_type s=size${attr_name}();
  v.resize(s);
  v.assign(get${attr_name}(),get${attr_name}()+s);
  return v;
}

inline $ctype 
NS_Analysis::${class_name}::
get${attr_name}(size_type n) const
{
#ifndef NO_RANGE_CHECKS
  // Version check is in size${attr_name}()
  size_type s=size${attr_name}();
  if(n>=s)
    {
      OutOfRange err("${class_name}::get${attr_name}",n);
      err.stream() << "Attempt to access element ${attr_name}[" << n 
	           <<"] is out of range in version " << version() 
                   << " of ${class_name}" << endl;
      throw(err);
    }
#else
#ifndef NO_VERSION_CHECK
  // Do version check here if we aren't doing size checking
  if(!has${attr_name}())
    {
      UnsupportedByVersion err("${class_name}::get${attr_name}",
                               "${attr_name}",version());
      err.stream() << "Element ${attr_name} is not supported by version " 
                   << version() << " of ${class_name}" << endl;
      throw(err);
    }
#endif
#endif
  return *(get${attr_name}()+n);
}
    @elsif((defined $dim)&&($attr_type eq "string"))
// Member: $attr_name
inline std::string& 
NS_Analysis::${class_name}::
get${attr_name}(std::string& s) const
{
  // Version check is in size${attr_name}()
  size_type size=size${attr_name}();
  size_type n=0;
  while((n<size)&&(m_${attr_name}[n]!=0))n++;
  s.resize(n);
  s.replace(0,n,m_${attr_name});
  return s;
}

inline std::string 
NS_Analysis::${class_name}::
get${attr_name}() const
{ 
  // Version check is in size${attr_name}()
  size_type size=size${attr_name}();
  size_type n=0;
  while((n<size)&&(m_${attr_name}[n]!=0))n++;
  return std::string(m_${attr_name},n);
}
    @else   
inline $ctype 
NS_Analysis::${class_name}::
get${attr_name}() const 
{ 
#ifndef NO_VERSION_CHECK
  if(!has${attr_name}())
    {
      UnsupportedByVersion err("${class_name}::get${attr_name}",
                               "${attr_name}",version());
      err.stream() << "Element ${attr_name} is not supported by version " 
                   << version() << " of ${class_name}" << endl;
      throw(err);
    }
#endif
  return m_${attr_name}; 
}
    @endif

  @end
///////////////////////////////////////////////////////////////////////////////
////////////////////////////// SET ACCESSORS //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// There may not be any functions here if there are no members that are
// arrays or strings. Don't be scared if there aren't

  @foreach attr_list 
    @if ( not defined $readonly )
      @perl $lcname=Utility::LCName($attr_name);
      @perl $ctype=Utility::MType($attr_type);
      @if((defined $dim)&&($attr_type ne "string"))
// Member: $attr_name
inline void 
NS_Analysis::${class_name}::
set${attr_name}(const ${ctype}* x)
{
  size_type s=size${attr_name}();
  for(unsigned int i=0;i<s;i++)m_${attr_name}[i]=x[i];
}

inline void 
NS_Analysis::${class_name}::
set${attr_name}(const std::vector<$ctype>& v)
{
  size_type s=size${attr_name}();
  size_type n=v.size();
#ifndef NO_RANGE_CHECKS
  if(n!=s)
    {
      OutOfRange err("${class_name}::get${attr_name}",n);
      err.stream() << "Attempt to access element ${attr_name}[" << n 
	           <<"] is out of range in version " << version() 
                   << " of ${class_name}" << endl;
      throw(err);
    }
#endif
  for(unsigned int i=0;i<n;i++)m_${attr_name}[i]=v[i];
}

inline void 
NS_Analysis::${class_name}::
set${attr_name}(const ${ctype}& x,size_type n)
{
  size_type s=size${attr_name}();
#ifndef NO_RANGE_CHECKS
  if(n>=s)
    {
      OutOfRange err("${class_name}::get${attr_name}",n);
      err.stream() << "Attempt to access element ${attr_name}[" << n 
	           <<"] is out of range in version " << version() 
                   << " of ${class_name}" << endl;
      throw(err);
    }
#endif
  m_${attr_name}[n]=x;
}

      @elsif((defined $dim)&&($attr_type eq "string"))
// Member: $attr_name
inline void
NS_Analysis::${class_name}::
set${attr_name}(const std::string& s)
{
  size_type n=size${attr_name}();
  s.copy(m_${attr_name},n);
  if(s.length()<n)m_${attr_name}[s.length()]=0;
}

      @endif
    @endif
  @end
///////////////////////////////////////////////////////////////////////////////
//////////////////////////// MEMBER DIMENSIONS ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// There may not be any functions here if there are no members that are
// arrays. Don't be scared if there aren't

  @foreach attr_list 
    @if(defined $dim)
inline NS_Analysis::${class_name}::size_type 
NS_Analysis::${class_name}::
size${attr_name}(unsigned int v)
{
#ifndef NO_VERSION_CHECK
  if(!has${attr_name}(v))
    {
      UnsupportedByVersion err("${class_name}::get${attr_name}",
                               "${attr_name}",v);
      err.stream() << "Element ${attr_name} is not supported by version " 
                   << v << " of ${class_name}" << endl;
      throw(err);
    }
#endif
  size_type s;
      @if(defined $dimfunction)
  s=$dimfunction(v);
#ifndef NO_RANGE_CHECKS
  if(s>$dim)
    {
      OutOfRange err("${class_name}::size${attr_name}",s);
      err.stream() << "\\"Very-Strange-Error\\" error. It seemed that "
                   << "the dimension function for this class ($dimfunction) "
                   << "returned a size > maxdimensions (" 
                   << s << " > $dim)" << endl;
      throw err;
    }
#endif
      @else
  s=$dim;
      @endif
  return s;
}

    @endif
  @end
///////////////////////////////////////////////////////////////////////////////
///////////////////////////// VERSION CHECKS //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
  @foreach attr_list 
    @if($version)

      @perl $vmatch=Utility::ExpandVersion($version);
inline bool 
NS_Analysis::${class_name}::
has${attr_name}(unsigned int v)
{
  if($vmatch)return true;
  else return false;
}
    @endif
  @end

#endif /* $myexclusion */
@end
